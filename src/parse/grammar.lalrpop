use std::rc::Rc;
use std::str::FromStr;
use crate::expr::{RecNode, Node, NodeLike};
use lalrpop_util::ParseError;

grammar<N>()
where
    N: NodeLike,
    N::Constant: FromStr,
    N::Variable: FromStr,
    N::Operator: FromStr
;

extern {
    type Error = String;
}


Ident: String = r"[a-zA-Z0-9+=\-*^&$%@!]+" => <>.into();

pub Term: RecNode<N> = {
    <name:Ident> =>? {
        let c = name.parse::<N::Constant>().map(Node::Constant);
        let v = name.parse::<N::Variable>().map(Node::Variable);
        c.or(v)
            .map(RecNode::from)
            .map_err(|_| ParseError::User {
                error: format!("{} is neither constant or variable", name)
            })
    },
    "(" <op:Ident> <args:Term*> ")" =>? {
        op.parse::<N::Operator>()
            .map_err(|_| ParseError::User{
                error: format!("{} is not an operator", op)
            })
            .map(|op| {
                let args = args.into_iter().map(RecNode::from).map(Rc::new).collect();
                Node::Operator(op, args).into()
            })
    },
};
